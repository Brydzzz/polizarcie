generator client {
    provider = "prisma-client-js"
}

datasource db {
    url      = env("DATABASE_URL")
    provider = "postgresql"
}

model User {
    // required by Next-Auth
    id                  String             @id @default(cuid())
    name                String?
    email               String             @unique
    emailVerified       DateTime?
    image               String?
    accounts            Account[]
    sessions            Session[]
    Authenticator       Authenticator[]
    createdAt           DateTime           @default(now())
    updatedAt           DateTime           @updatedAt
    // Custom
    gender              Gender             @default(NOT_SET)
    profferedGender     Gender             @default(NOT_SET)
    meetingStatus       Boolean            @default(false)
    points              Int                @default(0)
    medias              UserMedia[]
    favoriteRestaurants Restaurant[]
    restaurantReviews   RestaurantReview[]
    dishReviews         DishReview[]
    follows             Follow[]           @relation(name: "followUsersFrom")
    followedBy          Follow[]           @relation(name: "followUsersTo")
}

model UserMedia {
    id     String    @id @default(cuid())
    type   MediaType
    link   String
    user   User?     @relation(fields: [userId], references: [id])
    userId String?
}

model Restaurant {
    id             String             @id @default(cuid())
    name           String             @unique
    address        Address?           @relation(fields: [addressId], references: [id])
    addressId      String?            @unique
    description    String
    openingHourMon DateTime           @db.Time()
    closingHourMon DateTime           @db.Time()
    openingHourTue DateTime           @db.Time()
    closingHourTue DateTime           @db.Time()
    openingHourWen DateTime           @db.Time()
    closingHourWen DateTime           @db.Time()
    openingHourThu DateTime           @db.Time()
    closingHourThu DateTime           @db.Time()
    openingHourFri DateTime           @db.Time()
    closingHourFri DateTime           @db.Time()
    openingHourSat DateTime           @db.Time()
    closingHourSat DateTime           @db.Time()
    openingHourSun DateTime           @db.Time()
    closingHourSun DateTime           @db.Time()
    reviews        RestaurantReview[]
    menu           Dish[]
    favoriteAmong  User[]
}

model Dish {
    id          String       @id @default(cuid())
    name        String
    description String
    price       Decimal      @db.Money
    totalStars  Int
    owner       Restaurant   @relation(fields: [ownerId], references: [id])
    ownerId     String
    reviews     DishReview[]
}

model Address {
    id         String      @id @default(cuid())
    name       String
    xCoords    Decimal
    yCoords    Decimal
    restaurant Restaurant?
}

model RestaurantReview {
    id           String     @id @default(cuid())
    content      String
    restaurant   Restaurant @relation(fields: [restaurantId], references: [id])
    restaurantId String
    stars        Int
    amountSpent  Decimal    @db.Money
    date         DateTime   @db.Date
    user         User       @relation(fields: [userId], references: [id])
    userId       String
}

model DishReview {
    id      String   @id @default(cuid())
    content String
    dish    Dish     @relation(fields: [dishId], references: [id])
    dishId  String
    stars   Int
    date    DateTime @db.Date
    user    User     @relation(fields: [userId], references: [id])
    userId  String
}

model Follow {
    id     String   @id @default(cuid())
    from   User     @relation(name: "followUsersFrom", fields: [fromId], references: [id])
    fromId String
    to     User     @relation(name: "followUsersTo", fields: [toId], references: [id])
    toId   String
    date   DateTime @db.Timestamp()
}

// Required by Next-Auth
model Account {
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String?
    access_token      String?
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String?
    session_state     String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([provider, providerAccountId])
}

model Session {
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
    credentialID         String  @unique
    userId               String
    providerAccountId    String
    credentialPublicKey  String
    counter              Int
    credentialDeviceType String
    credentialBackedUp   Boolean
    transports           String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([userId, credentialID])
}

enum Gender {
    FEMALE
    MALE
    NOT_SET
    NON_BINARY
}

enum MediaType {
    FACEBOOK
}
